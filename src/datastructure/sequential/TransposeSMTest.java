package datastructure.sequential;

// 희소행렬 실습
/*
transposeSM(a[])
    m ← a[0,0]; // 희소행렬 a의 행 수
    n ← a[0,1]; // 희소행렬 a의 열 수
    v ← a[0,2]; // 희소행렬 a에서 0이 아닌 원소 수

    b[0,0] ← n; // 전치행렬 b의 행 수 지정
    b[0,1] ← m; // 전치행렬 b의 열 수 지정
    b[0,2] ← v; // 전치행렬 b의 0이 아닌 원소수 지정

    if(v > 0) then { // 0이 아닌 원소가 있는 경우에만 전치 연산 수행
        p ← 1;
        for (i ← 0; i < n; i ← i+1) do { // 희소행렬 a의 열별로 전치 반복 수행
            for(j ← 1; j <= v; j ← j+1) do { // 0이 아닌 원소 수에 대해서만 반복 수행
                if(a[j,i] = i) then {
                    b[p,0] ← a[j,1];
                    b[p,1] ← a[j,0];
                    b[p,2] ← a[j,2];
                    p ← p+1;
                }
            }
        }
    }

    return b[];
 End transposeSM()
*/

import java.util.Arrays;

public class TransposeSMTest {
    public static void main(String[] args) {
        int[][] matrix = {
                {0, 0, 2, 0, 0, 0, 12},
                {0, 0, 0, 0, 7, 0, 0},
                {23, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 31, 0, 0, 0},
                {0, 13, 0, 0, 0, 25, 0},
                {0, 0, 0, 0, 0, 0, 6},
                {52, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 11, 0, 0}
        };

        int m = matrix.length;    // 원본 행 수 : 8
        int n = matrix[0].length; // 원본 열 수 : 7
        int v = 0;                // 0이 아닌 값의 개수

        // 0이 아닌 원소의 개수 구하기
        for(int i = 0; i<m; i++) {
            for(int j=0; j<n; j++) {
                if(matrix[i][j] != 0)
                    v++;
            }
        }

        // 희소행렬 a 생성
        // 첫 행 : [전체행, 전체열, 값의 개수]
        int[][] a = new int[v+1][3];
        a[0][0] = m;
        a[0][1] = n;
        a[0][2] = v;


        int index = 1; // 실제 값들을 저장할 위치 (1번 인덱스 부터)
        for(int i=0; i<m; i++) {
            for(int j=0; j<n; j++) {
                if(matrix[i][j] != 0) {
                    a[index][0] = i;            // 행 위치
                    a[index][1] = j;            // 열 위치
                    a[index][2] = matrix[i][j]; // 실제 값
                    index++;
                }
            }
        }

        /*
        결과 : 원본 배열에서 m번 행의 n번째 열에 값이 있다!
        [행, 열, 값]
        [8, 7, 10],
        [0, 2, 2],
        [0, 6, 12],
        [1, 4, 7],
        [2, 0, 23],
        [3, 3, 31],
        [4, 1, 13],
        [4, 5, 25],
        [5, 6, 6],
        [6, 0, 52],
        [7, 4, 11]
        */

        // 전치행렬 b 생성
        int[][] b = new int[v+1][3];

        b[0][0] = n;  // b의 행 = a의 열
        b[0][1] = m;  // b의 열 = a의 행
        b[0][2] = v;

        if(v > 0) {
            int p = 1; // 전치행렬 b의 실제 값들을 저장할 위치 (1번 인덱스 부터)

            // i는 원본의 열 번호 이자, 전치행렬의 행 번호
            // b의 행 번호를 0부터 순서대로 완성하기 위해 i를 0부터 n까지 돌림
            for(int i=0; i<n; i++) {
                // 희소행렬 a의 모든 데이터(1~v번)을 반복문을 통해 계속 확인
                for(int j=1; j<=v; j++) {
                    // 찾고 있는 열 번호(i)와 일치하는 원소가 a에 있는지 확인
                    // 예: i=0, j=4일 때 a[4][1]은 0, a[j][1] == i 충족 → b에 a의 행과 열을 바꾸어 저장
                    // 이 과정을 통해 b는 열 번호(n) 기준으로 오름차순 정렬이 되어 저장된다.
                    if(a[j][1] == i) {
                        b[p][0] = a[j][1]; // 원본의 열 번호 -> 전치행렬의 행 번호
                        b[p][1] = a[j][0]; // 원본의 행 번호 -> 전치행렬의 열 번호
                        b[p][2] = a[j][2];
                        p++;
                    }
                }
            }
        }

        /*
        결과 : 원본 배열에서 n번 열의 m번째 행에 값이 있다!
        [행, 열, 값]
        [7, 8, 10],
        [0, 2, 23],
        [0, 6, 52],
        [1, 4, 13],
        [2, 0, 2],
        [3, 3, 31],
        [4, 1, 7],
        [4, 7, 11],
        [5, 4, 25],
        [6, 0, 12],
        [6, 5, 6]
        */

        System.out.println(Arrays.deepToString(a));
        System.out.println(Arrays.deepToString(b));


    }
}
